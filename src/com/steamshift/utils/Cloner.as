package com.steamshift.utils{	import com.steamshift.datatypes.Enum;		import flash.display.DisplayObject;	import flash.geom.Transform;	import flash.utils.ByteArray;	import flash.utils.describeType;	import flash.utils.getDefinitionByName;	import flash.utils.getQualifiedClassName;
		// attempts to produce a complete definition of an object	// will only work for public properties or those with accessors	public class Cloner	{		public static var debugTrace:Function = null;		public static var outputTrace:Function = trace;				// this creates a new object that contains all of the accessible properties of an object		public static function clone (obj:*, cloneOnly:Array = null, ignore:Array = null):*		{			if (obj.hasOwnProperty("clone")) return obj.clone();			if (isPrimitive(obj)) return obj;						var ClassReference:Class = getDefinitionByName(getQualifiedClassName(obj)) as Class;			var clone:* = new ClassReference();			var def:XML = describeType(obj);			var name:String;			var variable:XML;							if (def.@isDynamic == "true")			{					for (var key:* in obj)				{					name = key.toString();										variable = <variable/>;					variable.@name = name = key.toString();					variable.@access = "readwrite";					if (_canClone(variable, cloneOnly, ignore))					{						if (debugTrace != null) debugTrace("[Cloner]", ": cloning", name);						clone[key] = _clone(obj[key], cloneOnly, ignore, clone);					}				}			} else {				var variables:XMLList = _getAccessors(obj);								for each (variable in variables)				{					name = variable.@name;										if (_canClone(variable, cloneOnly, ignore)) 					{						var value:* = obj[name];						if (debugTrace != null) debugTrace("[Cloner]", ": cloning", name);						clone[name] = _clone(value, cloneOnly, ignore, clone);					}				}			}						return clone;		}				//traces out a set of assignments that will create a new object from the existing one		public static function outputObjectBuilder (objName:String, obj:*, cloneOnly:Array = null, ignore:Array = null):void		{			var className:String = getQualifiedClassName(obj);			outputTrace(objName + ' = new ' + className + '();'); 						// Object class doesn't give a definition using getDefinitionByName			if (className == 'Object')			{				for (var prop:String in obj)				{					if (!ignore || ignore.indexOf(prop) == -1)					{						_trace(objName + '.' + prop, obj[prop], cloneOnly, ignore);					}				}			} else {				var variables:XMLList = _getAccessors(obj);								for each (var variable:XML in variables)				{					var name:String = variable.@name;										if (_canClone(variable, cloneOnly, ignore)) 					{						var value:* = obj[name];						_trace(objName + '.' + name, value, cloneOnly, ignore);					}				}			}		}				protected static function _getAccessors (obj:*):XMLList		{			var def:XML = describeType(obj);						var variables:XMLList = def..variable;			var accessors:XMLList = def..accessor;						variables += accessors;						return variables;		}				protected static function _canClone (variable:XML, cloneOnly:Array, ignore:Array):Boolean		{			var name:String = String(variable.@name);			var access:String = String(variable.@access);			var meta:String = String(variable.metadata.@name);			switch (true)			{				case access != "" && access != "readwrite":			return false;				case meta == "Transient": 							return false;				case (ignore != null) && 					 (ignore.indexOf(name) > -1): 					return false;				case !cloneOnly:									return true;				case cloneOnly.indexOf(name) == -1:					return false;				default:											return true;			}		}				// this class is used for the actual cloning		// be warned that it doesn't check whether a property *can* be cloned 		protected static function _clone (value:*, cloneOnly:Array, ignore:Array, parent:*):*		{			switch (true)			{				case value == null:						return null;				case value == undefined:				return undefined;				case isPrimitive(value):				return value;				case value is Array:					return cloneArray(value, cloneOnly, ignore, parent);				case value is ByteArray:				var clone:ByteArray = new ByteArray;														ByteArray(value).position = 0;														clone.writeBytes(value);														return clone;				case value is Vector:					return cloneVector(value, cloneOnly, ignore, parent);				case value is Transform:				return cloneTransform(value, parent);				case value.hasOwnProperty("clone"): 	return value.clone();				default:								return Cloner.clone(value, cloneOnly, ignore);			}		}				protected static function _trace (valueName:String, value:*, cloneOnly:Array, ignore:Array):void		{			switch (true)			{				case value == null:				case value is ByteArray:				case value == undefined:				return;				case isPrimitive(value):									if (value is String)				outputTrace(valueName + ' = "' + value + '";');					else								outputTrace(valueName + ' = ' + value + ';');									break;				case value is Array:					outputArrayBuilder(valueName, value, cloneOnly, ignore);						break;				case value is Vector:					outputVectorBuilder(valueName, value, cloneOnly, ignore);						break;				case value is Transform:				outputTransformBuilder(valueName, value);										break;				default:								Cloner.outputObjectBuilder(valueName, value, cloneOnly, ignore);	break;			}			}				public static function isPrimitive (value:*):Boolean		{			return value is Boolean || value is Number || value is int || value is uint || value is String || value is Enum;			}				public static function cloneArray (value:Array, cloneOnly:Array, ignore:Array, parent:*):Array		{			var clone:Array = [];			var len:int = value.length;			for (var i:int = 0; i < len; i++)			{				clone[i] = _clone(value[i], cloneOnly, ignore, parent);			}						return clone;		}				public static function outputArrayBuilder (valueName:String, value:Array, cloneOnly:Array, ignore:Array):void		{			outputTrace(valueName + ' = [];');			var len:int = value.length;			for (var i:int = 0; i < len; i++)			{				_trace(valueName + '[' + i + ']', value[i], cloneOnly, ignore);			}		}				public static function cloneTransform (value:Transform, parent:DisplayObject):Transform		{			var clone:Transform = new Transform(parent);			clone.colorTransform = _clone(parent.transform.colorTransform, null, null, parent);			if (parent.transform.matrix) clone.matrix = parent.transform.matrix.clone();			if (parent.transform.matrix3D) clone.matrix3D = parent.transform.matrix3D.clone();						return clone;		}				public static function outputTransformBuilder (valueName:String, value:Transform):void		{			outputTrace('not outputting transforms as need to assign to parent: ' + value);		}				public static function cloneVector(value:Vector, cloneOnly:Array, ignore:Array, parent:*):Vector		{			var clone:Vector = new Vector();			var len:int = value.length;			for (var i:int = 0; i < len; i++)			{				clone[i] = _clone(value, cloneOnly, ignore, parent);			}						return clone;		}				public static function outputVectorBuilder(valueName:String, value:Vector, cloneOnly:Array, ignore:Array):void		{			outputTrace(valueName + ' = new Vector();');			var len:int = value.length;			for (var i:int = 0; i < len; i++)			{				_trace(valueName + '[' + i + ']', value, cloneOnly, ignore);			}		}				// makes a deep comparision between 2 objects, based on value, not strict equality		// for example {} != {} because they are different objects, but in terms of value, they are identical		public static function compare (obj1:*, obj2:*, compareOnly:Array = null, ignore:Array = null):Boolean		{			var qcn1:String = getQualifiedClassName(obj1);			var qcn2:String = getQualifiedClassName(obj2);			if (qcn1 != qcn2) 			{				if (debugTrace != null) debugTrace("[Cloner]", ": mismatch qualified class name", qcn1, qcn2);				return false;			}						if (obj1.hasOwnProperty("equals"))			{				if (debugTrace != null && !obj1.equals(obj2)) debugTrace("[Cloner]", ": built in equals method returned false", obj1.toString(), obj2.toString());				return obj1.equals(obj2);			}			else if (obj1.hasOwnProperty("equalTo"))			{				if (debugTrace != null && !obj1.equals(obj2)) debugTrace("[Cloner]", ": built in equalTo method returned false", obj1.toString(), obj2.toString());				return obj1.equalTo(obj2);			}						var def:XML = describeType(obj1);			var variable:XML;			var name:String;						if (def.@isDynamic == "true")			{				for (var key:* in obj1)				{					variable = <variable/>;					variable.@name = name = key.toString();					variable.@access = "readwrite";					if (obj2[key] == null || obj2[key] == undefined) return false;					else if (_canCompare(variable, compareOnly, ignore)) 					{						if (debugTrace != null) debugTrace("[Cloner]", ": comparing", name);						if (!_compare(obj1[name], obj2[name], compareOnly, ignore)) return false;					}				}			} else {				var variables:XMLList = def..variable;				var accessors:XMLList = def..accessor;								variables += accessors;								for each (variable in variables)				{					name = variable.@name;					if (_canCompare(variable, compareOnly, ignore)) 					{						if (debugTrace != null) debugTrace("[Cloner]", ": comparing", name);						if (!_compare(obj1[name], obj2[name], compareOnly, ignore)) return false;					}				}			}			return true;		}				protected static function _compare (value1:*, value2:*, compareOnly:Array, ignore:Array):Boolean		{			switch (true)			{				case value1 == value2:								return true;				case value1 == null && value2 != null:				if (debugTrace != null) debugTrace("[Cloner]", ": value1 is null, value2 is not"); return false;				case value1 != null && value2 == null:				if (debugTrace != null) debugTrace("[Cloner]", ": value2 is null, value1 is not"); return false;				case value1 is Array && value2 is Array:			return compareArray(value1 as Array, value2 as Array, compareOnly, ignore);				case value1 is Vector && value2 is Vector:			return compareVector(value1 as Vector, value2 as Vector, compareOnly, ignore);				case !isPrimitive(value1) && !isPrimitive(value2):	return compare(value1, value2, compareOnly, ignore);				default:											if (debugTrace != null) debugTrace("[Cloner]", ": couldn't find a match"); return false;			}		}				protected static function _canCompare (variable:XML, compareOnly:Array, ignore:Array):Boolean		{			var name:String = String(variable.@name);			var access:String = String(variable.@access);			switch (true)			{				case access == "writeonly":							return false;				case (ignore != null) && 					 (ignore.indexOf(name) > -1): 					return false;				case !compareOnly:									return true;				case compareOnly.indexOf(name) == -1:				return false;				default:											return true;			}		}				public static function compareArray (array1:Array, array2:Array, compareOnly:Array = null, ignore:Array = null):Boolean		{			var len:int = array1.length;			if (array2.length != len) return false;			for (var i:int = 0; i < len; i++)			{				if (!_compare(array1[i], array2[i], compareOnly, ignore)) return false;			}			return true;		}				public static function compareVector (vec1:Vector, vec2:Vector, compareOnly:Array = null, ignore:Array = null):Boolean		{			var len:int = vec1.length;			if (vec2.length != len) return false;			for (var i:int = 0; i < len; i++)			{				if (!_compare(vec1[i], vec2[i], compareOnly, ignore)) return false;			}			return true;			}	}}