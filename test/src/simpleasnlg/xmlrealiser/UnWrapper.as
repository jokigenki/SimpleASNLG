/*
 * The contents of this file are subject to the Mozilla Public License
 * Version 1.1 (the "License"); you may not use this file except in
 * compliance with the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 *
 * Software distributed under the License is distributed on an "AS IS"
 * basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
 * License for the specific language governing rights and limitations
 * under the License.
 *
 * The Original Code is "Simplenlg".
 *
 * The Initial Developer of the Original Code is Ehud Reiter, Albert Gatt and Dave Westwater.
 * Portions created by Ehud Reiter, Albert Gatt and Dave Westwater are Copyright (C) 2010-11 The University of Aberdeen. All Rights Reserved.
 *
 * Actionscript Conversion by Owen Bennett
*
* Contributor(s): Ehud Reiter, Albert Gatt, Dave Wewstwater, Roman Kutlak, Margaret Mitchell, Owen Bennett
 */
package simpleasnlg.xmlrealiser
{
	import java.io.Reader;
	import java.util.Array;
	
	import javax.xml.bind.JAXBContext;
	import javax.xml.bind.Unmarshaller;
	
	import simpleasnlg.features.ClauseStatus;
	import simpleasnlg.features.DiscourseFunction;
	import simpleasnlg.features.Feature;
	import simpleasnlg.features.Form;
	import simpleasnlg.features.Inflection;
	import simpleasnlg.features.InternalFeature;
	import simpleasnlg.features.LexicalFeature;
	import simpleasnlg.features.Person;
	import simpleasnlg.features.Tense;
	import simpleasnlg.framework.CoordinatedPhraseElement;
	import simpleasnlg.framework.DocumentCategory;
	import simpleasnlg.framework.DocumentElement;
	import simpleasnlg.framework.ElementCategory;
	import simpleasnlg.framework.InflectedWordElement;
	import simpleasnlg.framework.LexicalCategory;
	import simpleasnlg.framework.NLGElement;
	import simpleasnlg.framework.NLGFactory;
	import simpleasnlg.framework.PhraseCategory;
	import simpleasnlg.framework.PhraseElement;
	import simpleasnlg.framework.WordElement;
	import simpleasnlg.lexicon.Lexicon;
	import simpleasnlg.phrasespec.AdjPhraseSpec;
	import simpleasnlg.phrasespec.AdvPhraseSpec;
	import simpleasnlg.phrasespec.NPPhraseSpec;
	import simpleasnlg.phrasespec.PPPhraseSpec;
	import simpleasnlg.phrasespec.SPhraseSpec;
	import simpleasnlg.phrasespec.VPPhraseSpec;
	
	// TODO: Auto-generated Javadoc
	/**
	 * UnWrapper maps from classes generated by xjc from RealizerSchema.xsd to
	 * SimpleNLG classes. There are classes of the same name in two packages. The
	 * xjc wrapper classes are in the simpleasnlg.xmlrealiser.wrapper package, and are
	 * prefixed with the package name. The real simplenlg classes are referenced
	 * without package name prefix.
	 * 
	 * @author Christopher Howell Agfa Healthcare Corporation
	 * @author Albert Gatt, University of Malta
	 * 
	 */
	public class UnWrapper {
	
		/**
		 * Create wrapper objects from xml for a request to realise, or the xml for
		 * a recording. Both are elements of NLGSpec.
		 * 
		 * @param xmlReader
		 *            the xml reader
		 * @return the nLG spec
		 * @throws XMLRealiserException
		 *             the xML realiser exception
		 */
		public static simpleasnlg.xmlrealiser.wrapper.NLGSpec getNLGSpec(
				Reader xmlReader) throws XMLRealiserException {
			simpleasnlg.xmlrealiser.wrapper.NLGSpec wt = null;
			try {
				JAXBContext jc = JAXBContext
						.newInstance(simpleasnlg.xmlrealiser.wrapper.NLGSpec.c
import com.steamshift.datatypes.Enum;

lass);
				Unmarshaller u = jc.createUnmarshaller();
				Object obj = u.unmarshal(xmlReader);
				if (obj is simpleasnlg.xmlrealiser.wrapper.NLGSpec) {
					wt = (simpleasnlg.xmlrealiser.wrapper.NLGSpec) obj;
				}
			}
	
			catch (Throwable e) {
				throw new XMLRealiserException("XML unmarshal error", e);
			}
	
			return wt;
		}
	
		/** The factory. */
		NLGFactory factory = null;
	
		/**
		 * Initialise an UnWrapper with a lexicon.
		 * 
		 * @param lexicon
		 *            the lexicon to use
		 */
		public UnWrapper(Lexicon lexicon) {
			factory = new NLGFactory(lexicon);
		}
	
		/**
		 * Create simplenlg objects from wrapper objects.
		 * 
		 * @param wt
		 *            the wrapper DocumentElement object
		 * @return the document element
		 */
		public DocumentElement UnwrapDocumentElement(
				simpleasnlg.xmlrealiser.wrapper.XmlDocumentElement wt) {
			DocumentElement t = factory.createDocument();
	
			if (wt.getCat() != null) {
				t.setCategory(Enum.valueOf(DocumentCategory.class, wt.getCat()
						.toString()));
			}
			if (wt.getTitle() != null) {
				t.setTitle(wt.getTitle());
			}
	
			for (simpleasnlg.xmlrealiser.wrapper.XmlNLGElement wp : wt.getChild()) {
				NLGElement p = UnwrapNLGElement(wp);
				t.addComponent(p);
			}
	
			return t;
		}
	
		/**
		 * Unwrap a <code>simpleasnlg.xmlrealiser.wrapper.NLGElement</code> and map it
		 * to a <code>simpleasnlg.framework.NLGElement</code>
		 * 
		 * @param wps
		 *            The wrapper object
		 * @return the NLGElement
		 */
		public simpleasnlg.framework.NLGElement UnwrapNLGElement(
				simpleasnlg.xmlrealiser.wrapper.XmlNLGElement wps) {
	
			if (wps == null) {
				return null;
			}
	
			if (wps is simpleasnlg.xmlrealiser.wrapper.XmlDocumentElement) {
				return (NLGElement) UnwrapDocumentElement((simpleasnlg.xmlrealiser.wrapper.XmlDocumentElement) wps);
			}
	
			// Handle coordinate phrase specs first, which will cause recursion.
			NLGElement cp = UnwrapCoordinatePhraseSpec(wps);
			if (cp != null) {
				return cp;
			}
	
			// Literal text.
			if (wps is simpleasnlg.xmlrealiser.wrapper.XmlStringElement) {
				simpleasnlg.xmlrealiser.wrapper.XmlStringElement wp = (simpleasnlg.xmlrealiser.wrapper.XmlStringElement) wps;
				NLGElement p = factory.createStringElement(wp.getVal());
				return p;
			}
	
			// WordElements (delegate to UnwrapWordElement) -- useful to have
			// because it is called by unWrapPhraseComponents, and pre/post mods
			// might be WordElements
			if (wps is simpleasnlg.xmlrealiser.wrapper.XmlWordElement) {
				return UnwrapWordElement((simpleasnlg.xmlrealiser.wrapper.XmlWordElement) wps);
			}
	
			// Sentence
			else if (wps is simpleasnlg.xmlrealiser.wrapper.XmlSPhraseSpec) {
				simpleasnlg.xmlrealiser.wrapper.XmlSPhraseSpec wp = (simpleasnlg.xmlrealiser.wrapper.XmlSPhraseSpec) wps;
				SPhraseSpec sp = factory.createClause();
				NLGElement vp = null;
	
				Array<NLGElement> subjects = new Array<NLGElement>();
				for (simpleasnlg.xmlrealiser.wrapper.XmlNLGElement p : wp.getSubj()) {
					NLGElement p1 = UnwrapNLGElement(p);
					checkFunction(simpleasnlg.features.DiscourseFunction.SUBJECT, p1);
					subjects.push(p1);
				}
	
				if (subjects.length() > 0) {
					sp.setFeature(InternalFeature.SUBJECTS, subjects);
				}
	
				if (wp.getVp() != null) {
					vp = UnwrapNLGElement(wp.getVp());
					sp.setVerbPhrase(vp);
				}
	
				if (wp.getCuePhrase() != null) {
					NLGElement cue = UnwrapNLGElement(wp.getCuePhrase());
					cue.setFeature(InternalFeature.DISCOURSE_FUNCTION,
							DiscourseFunction.CUE_PHRASE);
					sp.setFeature(Feature.CUE_PHRASE, cue);
				}
	
				if (wp.getCOMPLEMENTISER() != null) {
					sp.setFeature(Feature.COMPLEMENTISER, wp.getCOMPLEMENTISER());
				}
	
				setSFeatures(wp, sp, vp);
	
				// Common phrase components.
				UnwrapPhraseComponents(sp, wps);
	
				return sp;
			}
	
			// Phrases
			else if (wps is simpleasnlg.xmlrealiser.wrapper.XmlPhraseElement) {
				simpleasnlg.xmlrealiser.wrapper.XmlPhraseElement we = (simpleasnlg.xmlrealiser.wrapper.XmlPhraseElement) wps;
				PhraseElement hp = null;
				simpleasnlg.xmlrealiser.wrapper.XmlWordElement w = we.getHead();
				NLGElement head = UnwrapWordElement(w);
	
				// Noun Phrase
				if (wps is simpleasnlg.xmlrealiser.wrapper.XmlNPPhraseSpec) {
					simpleasnlg.xmlrealiser.wrapper.XmlNPPhraseSpec wp = (simpleasnlg.xmlrealiser.wrapper.XmlNPPhraseSpec) wps;
	
					NPPhraseSpec p = factory.createNounPhrase(head);
					hp = p;
	
					if (wp.getSpec() != null) {
						// p.setSpecifier(UnwrapWordElement(wp.getSpec()));
						simpleasnlg.xmlrealiser.wrapper.XmlNLGElement spec = wp
								.getSpec();
	
						if (spec is simpleasnlg.xmlrealiser.wrapper.XmlWordElement) {
							WordElement specifier = (WordElement) UnwrapWordElement((simpleasnlg.xmlrealiser.wrapper.XmlWordElement) spec);
	
							if (specifier != null) {
								p.setSpecifier(specifier);
							}
	
						} else {
							p.setSpecifier(UnwrapNLGElement(spec));
						}
					}
	
					setNPFeatures(wp, p);
				}
	
				// Adjective Phrase
				else if (wps is simpleasnlg.xmlrealiser.wrapper.XmlAdjPhraseSpec) {
					simpleasnlg.xmlrealiser.wrapper.XmlAdjPhraseSpec wp = (simpleasnlg.xmlrealiser.wrapper.XmlAdjPhraseSpec) wps;
					AdjPhraseSpec p = factory.createAdjectivePhrase(head);
					hp = p;
	
					p.setFeature(Feature.IS_COMPARATIVE, wp.isISCOMPARATIVE());
					p.setFeature(Feature.IS_SUPERLATIVE, wp.isISSUPERLATIVE());
				}
	
				// Prepositional Phrase
				else if (wps is simpleasnlg.xmlrealiser.wrapper.XmlPPPhraseSpec) {
					PPPhraseSpec p = factory.createPrepositionPhrase(head);
					hp = p;
				}
	
				// Adverb Phrase
				else if (wps is simpleasnlg.xmlrealiser.wrapper.XmlAdvPhraseSpec) {
					simpleasnlg.xmlrealiser.wrapper.XmlAdvPhraseSpec wp = (simpleasnlg.xmlrealiser.wrapper.XmlAdvPhraseSpec) wps;
					AdvPhraseSpec p = factory.createAdverbPhrase();
					p.setHead(head);
					hp = p;
					p.setFeature(Feature.IS_COMPARATIVE, wp.isISCOMPARATIVE());
					p.setFeature(Feature.IS_SUPERLATIVE, wp.isISSUPERLATIVE());
				}
	
				// Verb Phrase
				else if (wps is simpleasnlg.xmlrealiser.wrapper.XmlVPPhraseSpec) {
					simpleasnlg.xmlrealiser.wrapper.XmlVPPhraseSpec wp = (simpleasnlg.xmlrealiser.wrapper.XmlVPPhraseSpec) wps;
					VPPhraseSpec p = factory.createVerbPhrase(head);
					hp = p;
					setVPFeatures(wp, p);
				}
	
				// Common phrase components.
				UnwrapPhraseComponents(hp, wps);
	
				// set the discourse function, if defined
				if (we.getDiscourseFunction() != null) {
					hp.setFeature(InternalFeature.DISCOURSE_FUNCTION, Enum.valueOf(
							simpleasnlg.features.DiscourseFunction.class, we
									.getDiscourseFunction().toString()));
				}
	
				return hp;
			}
	
			return null;
		}
	
		/**
		 * Unwrap the common phrase components (premodifiers, postmodifiers etc)
		 * that any <code>simpleasnlg.xmlrealiser.wrapper.NLGElement</code> can have,
		 * and map it to a <code>simpleasnlg.framework.NLGElement</code>
		 * 
		 * @param hp
		 *            the <code>simpleasnlg.framework.NLGElement</code> which is
		 *            cuurrently being constructed
		 * @param wps
		 *            The wrapper object
		 */
		public function UnwrapPhraseComponents(PhraseElement hp,
				simpleasnlg.xmlrealiser.wrapper.XmlNLGElement wps) {
	
			if (hp != null && wps != null) {
				simpleasnlg.xmlrealiser.wrapper.XmlPhraseElement wp = (simpleasnlg.xmlrealiser.wrapper.XmlPhraseElement) wps;
	
				for (simpleasnlg.xmlrealiser.wrapper.XmlNLGElement p : wp
						.getFrontMod()) {
					NLGElement p1 = UnwrapNLGElement(p);
					checkFunction(
							simpleasnlg.features.DiscourseFunction.FRONT_MODIFIER, p1);
	
					if (p1 != null) {
						hp.addFrontModifier(p1);
					}
				}
	
				for (simpleasnlg.xmlrealiser.wrapper.XmlNLGElement p : wp.getPreMod()) {
					NLGElement p1 = UnwrapNLGElement(p);
					checkFunction(
							simpleasnlg.features.DiscourseFunction.PRE_MODIFIER, p1);
	
					if (p1 != null) {
						hp.addPreModifier(p1);
					}
				}
	
				for (simpleasnlg.xmlrealiser.wrapper.XmlNLGElement p : wp
						.getPostMod()) {
					NLGElement p1 = UnwrapNLGElement(p);
					checkFunction(
							simpleasnlg.features.DiscourseFunction.POST_MODIFIER, p1);
	
					if (p1 != null) {
						hp.addPostModifier(p1);
					}
				}
	
				for (simpleasnlg.xmlrealiser.wrapper.XmlNLGElement p : wp.getCompl()) {
					NLGElement p1 = UnwrapNLGElement(p);
	
					// NB: set function to object by default, unless user set
					checkFunction(simpleasnlg.features.DiscourseFunction.OBJECT, p1);
	
					if (p1 != null) {
						hp.addComplement(p1);
					}
				}
			}
		}
	
		/**
		 * Unwraps a coordinate phrase.
		 * 
		 * @param wps
		 *            the <code>simpleasnlg.xmlrealiser.wrapper.NLGElement</code>
		 *            representing the phrase
		 * @return a <code>simpleasnlg.framework.CoordinatedPhraseElement</code> or
		 *         <code>null</code> if the wrapper element is not a coordinate
		 *         phrase.
		 */
		public NLGElement UnwrapCoordinatePhraseSpec(
				simpleasnlg.xmlrealiser.wrapper.XmlNLGElement wps) {
			NLGElement ret = null;
	
			// CoordinatedPhraseElement
			if (wps is simpleasnlg.xmlrealiser.wrapper.XmlCoordinatedPhraseElement) {
				simpleasnlg.xmlrealiser.wrapper.XmlCoordinatedPhraseElement wp = (simpleasnlg.xmlrealiser.wrapper.XmlCoordinatedPhraseElement) wps;
				CoordinatedPhraseElement cp = new CoordinatedPhraseElement();
				ElementCategory cat = UnwrapCategory(wp.getCat());
				if (cat != null && cat is PhraseCategory) {
					cp.setCategory(cat);
				}
				if (wp.getConj() != null) {
					String s = wp.getConj();
					if (s != null) {
						cp.setConjunction(s);
					}
				}
				if (wp.getPERSON() != null) {
					cp.setFeature(Feature.PERSON, wp.getPERSON());
				}
	
				cp.setFeature(Feature.POSSESSIVE, wp.isPOSSESSIVE());
	
				for (simpleasnlg.xmlrealiser.wrapper.XmlNLGElement p : wp.getCoord()) {
					NLGElement p1 = UnwrapNLGElement(p);
					if (p1 != null) {
						cp.addCoordinate(p1);
					}
	
				}
				ret = cp;
			}
	
			return ret;
		}
	
		/**
		 * Unwrap word element.
		 * 
		 * @param wordElement
		 *            the word element
		 * @return the nLG element
		 */
		private NLGElement UnwrapWordElement(
				simpleasnlg.xmlrealiser.wrapper.XmlWordElement wordElement) {
			if (wordElement == null) {
				return null;
			}
			LexicalCategory lexCat = LexicalCategory.ANY;
			ElementCategory cat = UnwrapCategory(wordElement.getCat());
	
			if (cat != null && cat is LexicalCategory) {
				lexCat = (LexicalCategory) cat;
			}
	
			// String baseForm = getBaseWord(wordElement);
			String baseForm = wordElement.getBase();
			NLGElement word = null;
	
			if (baseForm != null) {
				word = factory.createWord(baseForm, lexCat);
	
				if (word is InflectedWordElement
						&& ((InflectedWordElement) word).getBaseWord()
								.getBaseForm().isEmpty()) {
					word = null; // cch TESTING
	
				} else if (word is WordElement) {
					WordElement we = (WordElement) word;
	
					// Inflection
					if (wordElement.getVar() != null) {
						Inflection defaultInflection = Enum.valueOf(
								Inflection.class, wordElement.getVar().toString());
						we.setDefaultInflectionalVariant(defaultInflection);
					}
	
					// Spelling variant may have been given as base form in xml.
					// If so, use that variant.
					if (!baseForm.matches(we.getBaseForm())) {
						we.setDefaultSpellingVariant(baseForm);
					}
				}
			}
	
			return word;
		}
	
		// String getBaseWord(simpleasnlg.xmlrealiser.wrapper.WordElement lex) {
		// // List<String> c = lex.getContent();
		// // if (c.isEmpty())
		// // return "";
		// // else
		// // return (String) c[0];
		// return lex.getBase();
		//
		// }
	
		/**
		 * Unwrap category.
		 * 
		 * @param cat
		 *            the cat
		 * @return the element category
		 */
		private ElementCategory UnwrapCategory(Object cat) {
			if (cat == null) {
				return null;
			}
			if (cat.getClass().equals(
					simpleasnlg.xmlrealiser.wrapper.XmlLexicalCategory.class)) {
				return Enum.valueOf(LexicalCategory.class, cat.toString());
			} else if (cat.getClass().equals(
					simpleasnlg.xmlrealiser.wrapper.XmlPhraseCategory.class)) {
				return Enum.valueOf(PhraseCategory.class, cat.toString());
			} else if (cat.getClass().equals(
					simpleasnlg.xmlrealiser.wrapper.XmlDocumentCategory.class)) {
				return Enum.valueOf(DocumentCategory.class, cat.toString());
			} else {
				return null;
			}
		}
	
		/**
		 * Sets the np features.
		 * 
		 * @param wp
		 *            the wp
		 * @param p
		 *            the p
		 */
		private function setNPFeatures(
				simpleasnlg.xmlrealiser.wrapper.XmlNPPhraseSpec wp,
				simpleasnlg.phrasespec.NPPhraseSpec p) {
			if (wp.getNUMBER() != null) {
				// map number feature from wrapper ~NumberAgr to actual NumberAgr
				String numString = wp.getNUMBER().toString();
				simpleasnlg.features.NumberAgreement simplenlgNum = simpleasnlg.features.NumberAgreement
						.valueOf(numString);
				// p.setFeature(Feature.NUMBER, wp.getNUMBER());
				p.setFeature(Feature.NUMBER, simplenlgNum);
			}
	
			if (wp.getPERSON() != null) {
				// map person feature from wrapper Person to actual Person
				String perString = wp.getPERSON().toString();
				simpleasnlg.features.Person simplenlgPers = simpleasnlg.features.Person
						.valueOf(perString);
				p.setFeature(Feature.PERSON, simplenlgPers);
			}
	
			if (wp.getGENDER() != null) {
				// map gender feature from wrapper Gender to actual Gender
				String genString = wp.getGENDER().toString();
				simpleasnlg.features.Gender simplenlgGen = simpleasnlg.features.Gender
						.valueOf(genString);
				p.setFeature(LexicalFeature.GENDER, simplenlgGen);
			}
	
			p.setFeature(Feature.ELIDED, wp.isELIDED());
			p.setFeature(Feature.POSSESSIVE, wp.isPOSSESSIVE());
			p.setFeature(Feature.PRONOMINAL, wp.isPRONOMINAL());
	
		}
	
		/**
		 * Sets the vp features.
		 * 
		 * @param wp
		 *            the wp
		 * @param p
		 *            the p
		 */
		private function setVPFeatures(
				simpleasnlg.xmlrealiser.wrapper.XmlVPPhraseSpec wp,
				simpleasnlg.phrasespec.VPPhraseSpec p) {
			if (wp.getFORM() != null) {
				p.setFeature(Feature.FORM, Enum.valueOf(Form.class, wp.getFORM()
						.toString()));
			}
	
			if (wp.getPERSON() != null) {
				p.setFeature(Feature.PERSON, wp.getPERSON());
			}
	
			if (wp.getTENSE() != null) {
				p.setFeature(Feature.TENSE, Enum.valueOf(Tense.class, wp.getTENSE()
						.toString()));
			}
	
			if (wp.getMODAL() != null) {
				p.setFeature(Feature.MODAL, wp.getMODAL());
			}
	
			p.setFeature(Feature.NEGATED, wp.isNEGATED());
			p.setFeature(Feature.PASSIVE, wp.isPASSIVE());
			p.setFeature(Feature.PERFECT, wp.isPERFECT());
			p.setFeature(Feature.PROGRESSIVE, wp.isPROGRESSIVE());
		}
	
		/**
		 * ~Set the features for a sentence. This method also checks whether any
		 * features have been set on the VP, in which case, they are set if they
		 * haven't been set on the S
		 * 
		 * @param wp
		 *            the wp
		 * @param sp
		 *            the sp
		 * @param vp
		 *            the vp
		 */
		private function setSFeatures(simpleasnlg.xmlrealiser.wrapper.XmlSPhraseSpec wp,
				simpleasnlg.phrasespec.SPhraseSpec sp,
				simpleasnlg.framework.NLGElement vp) {
	
			if (wp.getCLAUSESTATUS() != null) {
				sp.setFeature(InternalFeature.CLAUSE_STATUS, Enum.valueOf(
						ClauseStatus.class, wp.getCLAUSESTATUS().toString()));
			}
	
			if (wp.getPERSON() != null) {
				sp.setFeature(Feature.PERSON, Enum.valueOf(Person.class, wp
						.getPERSON().toString()));
			}
	
			if (wp.getFORM() != null) {
				sp.setFeature(Feature.FORM, Enum.valueOf(Form.class, wp.getFORM()
						.toString()));
			}
	
			if (wp.getTENSE() != null) {
				sp.setFeature(Feature.TENSE, Enum.valueOf(Tense.class, wp
						.getTENSE().toString()));
	
			} else if (vp != null && vp.hasFeature(Feature.TENSE)) {
				sp.setFeature(Feature.TENSE, vp.getFeature(Feature.TENSE));
			}
	
			// modal -- set on S or inherited from VP
			if (wp.getMODAL() != null) {
				sp.setFeature(Feature.MODAL, wp.getMODAL());
			} else if (vp != null && vp.hasFeature(Feature.MODAL)) {
				sp.setFeature(Feature.MODAL, vp.getFeature(Feature.MODAL));
			}
	
			// interrogative
			if (wp.getINTERROGATIVETYPE() != null) {
				sp.setFeature(Feature.INTERROGATIVE_TYPE, Enum.valueOf(
						simpleasnlg.features.InterrogativeType.class, wp
								.getINTERROGATIVETYPE().toString()));
			} else if (vp != null && vp.hasFeature(Feature.INTERROGATIVE_TYPE)) {
				sp.setFeature(Feature.INTERROGATIVE_TYPE, vp
						.getFeature(Feature.INTERROGATIVE_TYPE));
			}
	
			// passive: can be set on S or VP
			boolean sPass = wp.isPASSIVE() == null ? false : wp.isPASSIVE();
			boolean vPass = vp == null ? false : vp.getFeatureAsBoolean(
					Feature.PASSIVE).booleanValue();
			sp.setFeature(Feature.PASSIVE, sPass || vPass);
	
			// progressive: can be set on S or VP
			boolean sProg = wp.isPROGRESSIVE() == null ? false : wp.isPROGRESSIVE();
			boolean vProg = vp == null ? false : vp.getFeatureAsBoolean(
					Feature.PROGRESSIVE).booleanValue();
			sp.setFeature(Feature.PROGRESSIVE, sProg || vProg);
	
			// negation: can be set on S or VP
			boolean sNeg = wp.isNEGATED() == null ? false : wp.isNEGATED();
			boolean vNeg = vp == null ? false : vp.getFeatureAsBoolean(
					Feature.NEGATED).booleanValue();
			sp.setFeature(Feature.NEGATED, sNeg || vNeg);
		}
	
		/**
		 * Utility method to set the discourse function for phrase components,
		 * unless set by user
		 * 
		 * @param function
		 *            the function
		 * @param phrase
		 *            the phrase
		 */
		private function checkFunction(simpleasnlg.features.DiscourseFunction function,
				simpleasnlg.framework.NLGElement phrase) {
			if (!phrase.hasFeature(InternalFeature.DISCOURSE_FUNCTION)) {
				phrase.setFeature(InternalFeature.DISCOURSE_FUNCTION, function);
			}
		}
	}
}
